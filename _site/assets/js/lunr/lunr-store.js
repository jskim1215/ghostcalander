var store = [{
        "title": "알고리즘 트레이딩의 구성요소",
        "excerpt":"Prelude  트레이딩에 있어서 우위성이란 향후 전개될 법한 시장 행동에서 활용할 수 있는 통계적 이점을 이야기한다. 우위를 점하려면 무엇보다 먼저, 자신이 희망하는 시간 틀 내에서 특정 방향으로 시장이 움직일 확률이 현저히 높질 때 진입 시점을 찾아야 한다.   이른바 우위가 있는 시스템은 다음 3가지 요소로 구성된다.   1. 포트폴리오 선택 2. 진입 신호 &amp; 청산 신호 3. 평가 기준   1. 포트폴리오 선택   a. 포트폴리오란?   투자자들이 투자자금을 여러 종류의 자산에 분산 투자하게 될 때, 투자자가 소유하는 여러 종류의 자산의 집합(combination of assets)을 포트폴리오(portfolio)라고 부른다   b. 포트폴리오의 구성 요소     포트폴리오를 구성하는 자산의 종류   각 자산에 투자된 자금의 비중   c. 포트폴리오 필터링   시장의 전체적인 움직임이 진입 신호의 의도와 유사한지 파악하기 위한 일이다. 진입 신호가 단기적인 신호에 반응하지 않도록 막아주는 역할을 할 것이다. 우위성에서 유리한 상황이 아닌 시장을 제외하기 위해 다양한 요소를 활용해 필터를 만들어 테스트해볼 예정이다.   시간적으로 연산이 적은 알고리즘을 활용해 1차적으로 필터링 해주는 역할을 할 수 있도록 코드 작성할 때 신경쓸 것!!   2. 진입 신호 &amp; 청산 신호  a. 포지셔닝 전략  자신이 희망하는 시간 틀 내에서 특정 방향으로 움직일 확률이 현저히 높아질 때의 시점을 찾는 일. 진입을 계획하는 단계에서 퇴장 전략을 조화시켜야 원하는 수익을 낼 수 있다.   b. 공부 방향성  기존에 알려진 방법들에 대해 하루에 하나씩 분석해서 코드로 작성해보는 일기 형태로 포스팅을 진행해보려한다.  3. 평가  a. 백테스팅 평가  기간, 청산 포지션 등 요소들을 변화시켜가면서 시장의 평균보다 높은 수익률을 보이는 시스템을 발굴하기 위한 평가 기준을 만들어야 한다.   b. 공부 방향성  기존에 알고 있던 수익율, 승률과 같은 지표 대신에 사용할 수 있는 방법론에 대한 공부와 인공지능 공부를 병행할 예정이다. 수익율의 국소 최대점을 찾기 위한 방법론에 대해 공부해서 일주일에 하나 정도 포스팅을 해보려고한다.   ","categories": ["Algorithm_Trading"],
        "tags": ["Factor"],
        "url": "/algorithm_trading/AA1/",
        "teaser": null
      },{
        "title": "Average True Range란?",
        "excerpt":"1. TR(True Range) 정의  True Range(이하 TR)의 정의는 다음과 같다.  단순 변화량에서 만약 전일의 종가가 당일의 변화 폭을 넘었을 경우를 고려해준다.  수식으로 표현해주면 아래와 같다.   $TR = max(high,close_{previous})-min(low,close_{previous})$   즉 TR는 특정 간격의 주가 변동성을 나타낸다.   2. ATR (Average True Range) 정의   Average True Range(이하 ATR)은 특정 기간 t 동안 TR의 평균 값으로 정의한다.   $ATR_{t}= \\frac{ATR_{t-1} \\times (n-1)+TR_{t}}{n}$   즉 ATR은 주가 변동의 추이를 알려준다.   3. ATR (Average True Range) 적용  a. 포트폴리오 필터에 사용     상품에 따라 변동성 기준 투자 금액의 변화를 통한 리스크 관리에 사용가능            ATR에 따른 운용 자금의 투입 퍼센트 조정           b. 포지셔닝에 사용     상품에 따른 포지션 청산의 기준으로 사용가능            ATR * N  지점에서 포지션 청산       ATR이 운용 자금의 일부 퍼센트를 넘었을 때 포지션 청산           추세 시작점 판단 기준            감소하는 ATR =  포지션 진입  증가하는 ATR = 포지션 청산           c. 평가 기준에 사용     E-비율 (우위 비율) 계산에 사용   4. 기타          횡보 와 추세 과정과 관계성에 대해 백테스팅을 통해 파악해볼 것            급락 / 급등 기간에 대해 고민해볼 것 (ATR의 미분 불가능 지점)  계단식 증가 / 감소 역시 어떻게 알고리즘화 할 수 있을지 고민            단순 ATR은 가격의 변동성만 보여주기 때문에 거래량과 결합하여 새로운 지표를 만들어야한다는 생각이 들었음.            현재 생각으로는 낮은 ATR을 보이는 구간에서 매수를 해야한다고 생각함 맞는지는 백테스팅을 통해 확인해볼 것            급락이 나오는 지점에서 ATR이 감소하면 감소 추세가 줄어듦 = 포지션 진입 준비  급등이 나오는 지점에서 ATR이 감소하면 증가 추세가 줄어듦 =  포지션 진입 준비  ATR의 변화량이 중요한 건지 확인해볼 것      ","categories": ["Algorithm_Trading"],
        "tags": ["Factor"],
        "url": "/algorithm_trading/AA2/",
        "teaser": null
      },{
        "title": "업비트 과거 거래 기록 크롤링",
        "excerpt":"1. 코인 이름 크롤링  처음에는 Selenium을 활용해서 직접 사이트에 들어가서 html 태그 찾아서 크롤링하는 방법으로 진행해보려고 했다. 근데 업비트 사이트 보안 문제인지 잘 모르겠지만 사이트에 접속이 되지를 않아서 구글링을 하던 도중 업비트 API 사이트를 통해 쉽게 이름을 크롤링 할 수 있었다.   import requests from pandas import DataFrame import pandas as pd  def call_coin():     #coin 종류 가져오기     databox=[]     url = 'https://api.upbit.com/v1/market/all'     response = requests.get(url)     datas = response.json()     # 데이터 프레임으로 변경     df = pd.DataFrame(datas)     # market 기준 한화로 변경     coins_krw = df[df['market'].str.startswith('KRW')].reset_index(drop=True)     num_index = len(coins_krw.index)     for i in range(0, num_index):         empty = [coins_krw.iloc[i,0],coins_krw.iloc[i,2]]         databox.append(empty)     return databox  2. 2월달 코인 거래 1분봉 데이터 크롤링  과거 코인 데이터 크롤링에 사용했던 코드를 활용해서 for문을 추가해줬다. 사이트 상에서 한 번에 가져올 수 있는 데이터가 200개라서 for문을 잘 설정해서 데이터를 모아야했다.   1분 봉으로 데이터를 추출할 예정이기 때문에 한 번에 60개씩 데이터를 추출해서 최대한 카운팅을 맞춰보려고 노력했다. 처음 시범 데이터를 추출했을 때 총 40,320개의 데이터가 나와야하는데 BTC 기준 39,829개가 나오길래 사이사이 빈 곳을 어떻게 처리해야할지 고민이 됬다.   혹시 점검 시간이 고려되었을 가능성을 생각해서 추가로 ETH와 NEO 데이터를 비교해봤는데 아래 두 가지 방법 모두 같은 개수로 나와가지고 공식 API는 하다보니까 너무 많은 요청이 들어오면 에러가 발생해서 비공식 API로 알려진 방법을 활용했다.   공식 API   for coin in coin_names:     box = {}     for day in days:         for hour in hours:             url = \"https://api.upbit.com/v1/candles/minutes/1\"              querystring = {\"market\": coin[0], \"to\": \"2021-02-\"+day+\" \"+hour+\":00:00\", \"count\": \"60\"}              response = requests.request(\"GET\", url, params=querystring)             tradedata = response.json()             sleep(0.1)   비공식 API  for coin in coin_names:     box = {}     for day in days:         for hour in hours:             r = requests.get(\"https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.\"+coin[0]+\"&amp;count=60&amp;to=2021-02-\"+day+\"%20\"+hour+\":00:00\")             tradedata = r.json()   3. 전체 코드   전체 개수가 다 다르게 나오긴 하지만 API의 문제로 생각되서 둘 중 어느 방법을 활용하던 같은 결과가 나와서 일단 그대로 사용하기로 했다. 가격의 변동성에서 패턴을 읽는 과정에는 크게 어려움이 없다고 일단은 생각하고 진행하기로 했다.   추후 찾아보니까 거래량이 부족한 경우 1분 봉이 형성이 안되서 데이터 개수가 모자른 경우가 발생하는 것 같다.   마지막으로 완성한 전체 코드는 아래 첨부한다.  import requests import pandas as pd from time import sleep  def call_coin():     #coin 종류 가져오기     databox=[]     url = 'https://api.upbit.com/v1/market/all'     response = requests.get(url)     datas = response.json()     # 데이터 프레임으로 변경     df = pd.DataFrame(datas)     # market 기준 한화로 변경     coins_krw = df[df['market'].str.startswith('KRW')].reset_index(drop=True)     num_index = len(coins_krw.index)     for i in range(0, num_index):         empty = [coins_krw.iloc[i,0],coins_krw.iloc[i,2]]         databox.append(empty)     return databox  days = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28'] hours = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24']  coin_names=call_coin()  for coin in coin_names:     box = {}     for day in days:         for hour in hours:             r = requests.get(\"https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.\"+coin[0]+\"&amp;count=60&amp;to=2021-02-\"+day+\"%20\"+hour+\":00:00\")             tradedata = r.json()              for trade in reversed(tradedata):                 time = trade['candleDateTime']                 timedata = time[0:10] + \" \" + time[11:16]                 op = trade['openingPrice']  # op 는 시작 가격                 tp = trade['tradePrice']  # tp 는 종가                 lp = trade['lowPrice']  # lp 는 저가                 hp = trade['highPrice']  # hp 는 고가                 box[timedata] = [op, tp, hp, lp]      tradedata = pd.DataFrame(box)     tradedata.rename(index={0: \"Open Price\", 1: \"High Price\", 2: \"Low Price\", 3: 'Close Price'}, inplace=True)     transposed_tradedata = tradedata.transpose()     transposed_tradedata.to_excel(excel_writer='C:/Users/whdtlr/Bitcoin_desktop/coins/'+coin[1]+'.xlsx')     sleep(1)   현재 이렇게 크롤링 진행하면 request 함수에 오류가 발생하고 있다. 아마도 너무 많은 요청이 들어가서 오류가 발생한 것이라고 생각해서 sleep 함수를 활용해서 해결해보려 하고 있다.  ","categories": ["Algorithm_Trading"],
        "tags": ["BackTest"],
        "url": "/algorithm_trading/AE2/",
        "teaser": null
      },{
        "title": "돈키언 채널(Donchian Channel) (작성중)",
        "excerpt":"Prelude : 추세 추종 전략이란?  추세 추종 전략이란 차트 상의 데이터를 가지고 주가의 이동 방향에 대해 판단해 진입하는 트레이딩 방법 중 하나다. 주가가 중장기적인 저항대를 뚫고 올라갈 때 매수에 동참해 추세가 꺾일 때까지 보유하는 중장기적인 트레이딩 전략이다. 이 전략의 핵심은 비쌀 때 사서, 더 비싸지기를 기다리는 것이라고 할 수 있다.   추세 추종 전략의 단점은 시장의 $\\frac{2}{3}$ 이상은 추세적이지 않다는 것이다. 즉, 이 전략의 핵심은 오르면 떨어지고, 떨어지면 다시 반등하는 횡보장의 리스크를 어떻게 처리해주냐에 달려있다. 따라서, 장기 추세 추종 전략의 경우, 한 번 트레이딩에서 큰 수익을 얻어 전체적인 수익을 챙기는 방향으로 전략을 구사해야한다.  (일반적으로 추세 추종 전략의 승률은 30%대로 상당히 낮은 편이다)   1. 돈키언 채널  정의  일정 기간 N 동안의 고점의 최대값을 상선, 저점의 최소값을 하선으로 그린 채널 지표다. 채널이란, 특정 중심선을 기준으로 상하단에 일정한 폭의 범위를 설정해놓은 구간을 말한다.   코드  기본 구조     시간 t의 돈키언 채널값 : 시간 t에서 t-N에서 t-1까지의 데이터 사용   a. 반복문을 활용한 함수 정의  def donchian_max(df,t,N):   # t 는 시점 (건들지 말 것!)   max=df.iloc[(t-N),2]      # N은 기간 (N을 조정할 것!)   for i in range(1,N):       if df.iloc[(t-N+i),2] &gt;= max:           max = df.iloc[(t - N + i), 2]   return max  def donchian_min(df,t,N):   min=df.iloc[(t-N),3]   for i in range(1,N):       if df.iloc[(t-N+i),3] &lt;= min:         min = df.iloc[(t-N+i),3]   return min  b. List에 담아서 Max / min 함수 처리하기   def donchian_max(df,t,N):   # t 는 시점 (건들지 말 것!)   box=[]    # N은 기간 (N을 조정할 것!)   max_value=0   for i in range(0,N):     box.append(df.iloc[(t-N+i),2]) # 데이터 프레임 카운팅 주의   max_value=max(box)   return max_value  def donchian_min(df,t,N):   box=[]   min_value=0   for i in range(0,N):       box.append(df.iloc[(t-N+i),3]) # 데이터 프레임 카운팅 주의   min_value=min(box)   return min_value   연산 속도 비교 결과   Bitcoin 2월 1분봉 데이터를 가지고 10회 연산 평균값을 비교했을 때 방법 b의 함수가 속도가 더 빠르므로 사용하기로 결정했다.     a : 21.84초 / 1회   b : 18.22초 / 1회   2. 돈키언 채널 돌파  정의  돈키언 채널 돌파는 특정 기간의 최고가를 갱신했다는 점이 상승 추세를 반영해준다는 개념에서 시작한다. 실 적용에 있어 매수 포지션만 가능하므로 상단 돌파 추세와 관련된 필터를 적용하는 경우가 많다. 대표적으로 이동평균선을 활용한 추세 포트폴리오 필터가 사용된다.   일반적으로 20일선을 기준으로 상단 돌파시 매수, 하단 돌파시 매도를 하는 원칙이다. 하지만 거래 대상이 암호화폐 1분봉을 기준으로 하고 있으므로 시간 간격을 여러 수치를 대입해보면서 해석을 진행해보려고 한다. 추가로 일정 시간 간격 동안 상선이 같은 값을 유지하고 있는 조건을 추가하려고 한다.   코드  기본 구조     60분 이상 상선 유지   60분, 240분 정배열     # 카운팅 쉽게 하기 위해 앞뒤 각각 100개 잘라내버리기   for i in range(100, num_index-100):       if df.iloc[i,5]&gt;df.iloc[i,6] and df.iloc[i,5]&gt;df.iloc[i-1,5] and df.iloc[i,6]&gt;df.iloc[i-1,6]:           if df.iloc[i-1,7]&lt;df.iloc[i,4]:               target_value = df.iloc[i - 1, 7]               target_percent_list=[]           else:               pass       else:           pass           결과값 (그래프)  아직 Valuation에 대한 이해와 코드 공부가 부족하여 Target 가격에 대한 앞뒤 60분에 대한 움직임을 그래프화해서 표현해보려고 했다.  for k in range(0,31):                     target_percent_value=df.iloc[i-60+4*k,4]/target_value                     target_percent_list.append(target_percent_value)                 new_dict[df.iloc[i,0]]=target_percent_list   시가총액 상위 중 5개     Bitcoin         ChainLink        Litecoin    Ethereum    Polkadot      시가총액 하위 중 3개          Chiliz        Refereum    ThetaFuel    피드백  시가총액이 높은 암호화폐 5종과 시가총액이 낮은 3종을 비교해본 결과 유의미한 결과값을 보이지 않아서 고민해봐야할 것 같다. 단기 추세를 나타내주기에는 돈키언 채널 자체가 어려움이 있지 않나 채널의 성격에 대해 다시 한 번 생각해봐야겠다.   물론 Chilliz같은 케이스에서 유의미한 결과를 보여줬다. 그래서 펌핑이 나오는 순간을 캐치할 수 있는 알고리즘에 대해 공부를 해봐야할 것 같다.   일반적으로 장기적 추세에 사용되는 돈키언 채널과 관련해서 시가총액이 높은 암호화폐에 대해 일봉으로 다시 한 번 비교 분석해봐야겠다.  ","categories": ["Algorithm_Trading"],
        "tags": ["Position"],
        "url": "/algorithm_trading/AD1/",
        "teaser": null
      },{
        "title": "연산 속도 비교 코드 (작성중)",
        "excerpt":"코드  import time start = time.time()  # 시작 시간 저장  # 함수 입력칸  try_num=0 time_box=[] while try_num&lt;10: # 몇 번 반복할지   # 연산 코드   testing_time=(time.time() - start)   time_box.append(testing_time)   try_num+=1  average_testing_time=(sum(all_time_data)/len(all_time_data))  ","categories": ["Algorithm_Trading"],
        "tags": ["BackTest"],
        "url": "/algorithm_trading/AE3/",
        "teaser": null
      }]
